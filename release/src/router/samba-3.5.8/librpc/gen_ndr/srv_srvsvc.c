/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "../librpc/gen_ndr/srv_srvsvc.h"

static bool api_srvsvc_NetCharDevEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetCharDevEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetCharDevInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetCharDevGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevGetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevControl(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevControl *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVCONTROL];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevControl);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevControl, r);
	}

	r->out.result = _srvsvc_NetCharDevControl(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevControl, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetCharDevQEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetCharDevQInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetCharDevQGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQGetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQSetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQSETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQSetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQSetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetCharDevQSetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQSetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQPurge(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQPurge *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQPURGE];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQPurge);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQPurge, r);
	}

	r->out.result = _srvsvc_NetCharDevQPurge(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQPurge, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQPurgeSelf(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQPurgeSelf *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQPURGESELF];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQPurgeSelf);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQPurgeSelf, r);
	}

	r->out.result = _srvsvc_NetCharDevQPurgeSelf(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQPurgeSelf, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetConnEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetConnEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCONNENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetConnEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetConnEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetConnEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetConnEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetFileEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetFileEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETFILEENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetFileEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetFileEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetFileGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetFileGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETFILEGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetFileGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetFileInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetFileGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileGetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetFileClose(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetFileClose *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETFILECLOSE];

	r = talloc(talloc_tos(), struct srvsvc_NetFileClose);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileClose, r);
	}

	r->out.result = _srvsvc_NetFileClose(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileClose, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSessEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSessEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSESSENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetSessEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSessEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetSessEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSessEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSessDel(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSessDel *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSESSDEL];

	r = talloc(talloc_tos(), struct srvsvc_NetSessDel);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSessDel, r);
	}

	r->out.result = _srvsvc_NetSessDel(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSessDel, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareAdd(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareAdd *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREADD];

	r = talloc(talloc_tos(), struct srvsvc_NetShareAdd);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareAdd, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetShareAdd(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareAdd, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareEnumAll(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareEnumAll *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREENUMALL];

	r = talloc(talloc_tos(), struct srvsvc_NetShareEnumAll);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareEnumAll, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareEnumAll(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareEnumAll, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetShareGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetShareInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareGetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareSetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHARESETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetShareSetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareSetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetShareSetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareSetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDel(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDel *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDEL];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDel);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDel, r);
	}

	r->out.result = _srvsvc_NetShareDel(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDel, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDelSticky(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelSticky *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDELSTICKY];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDelSticky);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelSticky, r);
	}

	r->out.result = _srvsvc_NetShareDelSticky(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelSticky, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareCheck(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareCheck *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHARECHECK];

	r = talloc(talloc_tos(), struct srvsvc_NetShareCheck);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareCheck, r);
	}

	ZERO_STRUCT(r->out);
	r->out.type = talloc_zero(r, enum srvsvc_ShareType);
	if (r->out.type == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareCheck(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareCheck, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSrvGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSrvGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSRVGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetSrvGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSrvGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetSrvInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetSrvGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSrvGetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSrvSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSrvSetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSRVSETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetSrvSetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSrvSetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetSrvSetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSrvSetInfo, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetDiskEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetDiskEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETDISKENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetDiskEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetDiskEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = r->in.info;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetDiskEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetDiskEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetServerStatisticsGet(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetServerStatisticsGet *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSERVERSTATISTICSGET];

	r = talloc(talloc_tos(), struct srvsvc_NetServerStatisticsGet);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerStatisticsGet, r);
	}

	ZERO_STRUCT(r->out);
	r->out.stats = talloc_zero(r, struct srvsvc_Statistics *);
	if (r->out.stats == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetServerStatisticsGet(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerStatisticsGet, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetTransportAdd(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetTransportAdd *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETTRANSPORTADD];

	r = talloc(talloc_tos(), struct srvsvc_NetTransportAdd);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportAdd, r);
	}

	r->out.result = _srvsvc_NetTransportAdd(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportAdd, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetTransportEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetTransportEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETTRANSPORTENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetTransportEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.transports = r->in.transports;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetTransportEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetTransportDel(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetTransportDel *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETTRANSPORTDEL];

	r = talloc(talloc_tos(), struct srvsvc_NetTransportDel);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportDel, r);
	}

	r->out.result = _srvsvc_NetTransportDel(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportDel, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetRemoteTOD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetRemoteTOD *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETREMOTETOD];

	r = talloc(talloc_tos(), struct srvsvc_NetRemoteTOD);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetRemoteTOD, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, struct srvsvc_NetRemoteTODInfo *);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetRemoteTOD(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetRemoteTOD, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSetServiceBits(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSetServiceBits *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSETSERVICEBITS];

	r = talloc(talloc_tos(), struct srvsvc_NetSetServiceBits);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSetServiceBits, r);
	}

	r->out.result = _srvsvc_NetSetServiceBits(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSetServiceBits, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPathType(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPathType *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPATHTYPE];

	r = talloc(talloc_tos(), struct srvsvc_NetPathType);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathType, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pathtype = talloc_zero(r, uint32_t);
	if (r->out.pathtype == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetPathType(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathType, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPathCanonicalize(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPathCanonicalize *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPATHCANONICALIZE];

	r = talloc(talloc_tos(), struct srvsvc_NetPathCanonicalize);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathCanonicalize, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pathtype = r->in.pathtype;
	r->out.can_path = talloc_zero_array(r, uint8_t, r->in.maxbuf);
	if (r->out.can_path == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetPathCanonicalize(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathCanonicalize, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPathCompare(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPathCompare *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPATHCOMPARE];

	r = talloc(talloc_tos(), struct srvsvc_NetPathCompare);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathCompare, r);
	}

	r->out.result = _srvsvc_NetPathCompare(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathCompare, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetNameValidate(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetNameValidate *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETNAMEVALIDATE];

	r = talloc(talloc_tos(), struct srvsvc_NetNameValidate);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetNameValidate, r);
	}

	r->out.result = _srvsvc_NetNameValidate(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetNameValidate, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRPRNAMECANONICALIZE(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRPRNAMECANONICALIZE *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRPRNAMECANONICALIZE];

	r = talloc(talloc_tos(), struct srvsvc_NETRPRNAMECANONICALIZE);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRPRNAMECANONICALIZE, r);
	}

	r->out.result = _srvsvc_NETRPRNAMECANONICALIZE(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRPRNAMECANONICALIZE, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPRNameCompare(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPRNameCompare *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPRNAMECOMPARE];

	r = talloc(talloc_tos(), struct srvsvc_NetPRNameCompare);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPRNameCompare, r);
	}

	r->out.result = _srvsvc_NetPRNameCompare(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPRNameCompare, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetShareEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.resume_handle = r->in.resume_handle;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareEnum, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDelStart(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelStart *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDELSTART];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDelStart);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelStart, r);
	}

	ZERO_STRUCT(r->out);
	r->out.hnd = talloc_zero(r, struct policy_handle);
	if (r->out.hnd == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareDelStart(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelStart, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDelCommit(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelCommit *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDELCOMMIT];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDelCommit);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelCommit, r);
	}

	ZERO_STRUCT(r->out);
	r->out.hnd = r->in.hnd;
	r->out.result = _srvsvc_NetShareDelCommit(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelCommit, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetGetFileSecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetGetFileSecurity *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETGETFILESECURITY];

	r = talloc(talloc_tos(), struct srvsvc_NetGetFileSecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetGetFileSecurity, r);
	}

	ZERO_STRUCT(r->out);
	r->out.sd_buf = talloc_zero(r, struct sec_desc_buf *);
	if (r->out.sd_buf == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetGetFileSecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetGetFileSecurity, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSetFileSecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSetFileSecurity *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSETFILESECURITY];

	r = talloc(talloc_tos(), struct srvsvc_NetSetFileSecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSetFileSecurity, r);
	}

	r->out.result = _srvsvc_NetSetFileSecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSetFileSecurity, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetServerTransportAddEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetServerTransportAddEx *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSERVERTRANSPORTADDEX];

	r = talloc(talloc_tos(), struct srvsvc_NetServerTransportAddEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerTransportAddEx, r);
	}

	r->out.result = _srvsvc_NetServerTransportAddEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerTransportAddEx, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetServerSetServiceBitsEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetServerSetServiceBitsEx *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSERVERSETSERVICEBITSEX];

	r = talloc(talloc_tos(), struct srvsvc_NetServerSetServiceBitsEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerSetServiceBitsEx, r);
	}

	r->out.result = _srvsvc_NetServerSetServiceBitsEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerSetServiceBitsEx, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSGETVERSION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSGETVERSION *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSGETVERSION];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSGETVERSION);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSGETVERSION, r);
	}

	r->out.result = _srvsvc_NETRDFSGETVERSION(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSGETVERSION, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSCREATELOCALPARTITION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSCREATELOCALPARTITION *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSCREATELOCALPARTITION];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSCREATELOCALPARTITION);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSCREATELOCALPARTITION, r);
	}

	r->out.result = _srvsvc_NETRDFSCREATELOCALPARTITION(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSCREATELOCALPARTITION, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSDELETELOCALPARTITION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSDELETELOCALPARTITION *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSDELETELOCALPARTITION];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSDELETELOCALPARTITION);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSDELETELOCALPARTITION, r);
	}

	r->out.result = _srvsvc_NETRDFSDELETELOCALPARTITION(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSDELETELOCALPARTITION, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSSETLOCALVOLUMESTATE(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSSETLOCALVOLUMESTATE *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSSETLOCALVOLUMESTATE];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSSETLOCALVOLUMESTATE);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSSETLOCALVOLUMESTATE, r);
	}

	r->out.result = _srvsvc_NETRDFSSETLOCALVOLUMESTATE(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSSETLOCALVOLUMESTATE, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSSETSERVERINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSSETSERVERINFO *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSSETSERVERINFO];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSSETSERVERINFO);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSSETSERVERINFO, r);
	}

	r->out.result = _srvsvc_NETRDFSSETSERVERINFO(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSSETSERVERINFO, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSCREATEEXITPOINT(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSCREATEEXITPOINT *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSCREATEEXITPOINT];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSCREATEEXITPOINT);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSCREATEEXITPOINT, r);
	}

	r->out.result = _srvsvc_NETRDFSCREATEEXITPOINT(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSCREATEEXITPOINT, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSDELETEEXITPOINT(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSDELETEEXITPOINT *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSDELETEEXITPOINT];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSDELETEEXITPOINT);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSDELETEEXITPOINT, r);
	}

	r->out.result = _srvsvc_NETRDFSDELETEEXITPOINT(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSDELETEEXITPOINT, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSMODIFYPREFIX(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSMODIFYPREFIX *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSMODIFYPREFIX];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSMODIFYPREFIX);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSMODIFYPREFIX, r);
	}

	r->out.result = _srvsvc_NETRDFSMODIFYPREFIX(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSMODIFYPREFIX, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSFIXLOCALVOLUME(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSFIXLOCALVOLUME *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSFIXLOCALVOLUME];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSFIXLOCALVOLUME);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSFIXLOCALVOLUME, r);
	}

	r->out.result = _srvsvc_NETRDFSFIXLOCALVOLUME(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSFIXLOCALVOLUME, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSMANAGERREPORTSITEINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSMANAGERREPORTSITEINFO *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSMANAGERREPORTSITEINFO];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSMANAGERREPORTSITEINFO);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSMANAGERREPORTSITEINFO, r);
	}

	r->out.result = _srvsvc_NETRDFSMANAGERREPORTSITEINFO(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSMANAGERREPORTSITEINFO, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRSERVERTRANSPORTDELEX(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRSERVERTRANSPORTDELEX *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRSERVERTRANSPORTDELEX];

	r = talloc(talloc_tos(), struct srvsvc_NETRSERVERTRANSPORTDELEX);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRSERVERTRANSPORTDELEX, r);
	}

	r->out.result = _srvsvc_NETRSERVERTRANSPORTDELEX(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRSERVERTRANSPORTDELEX, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}


/* Tables */
static struct api_struct api_srvsvc_cmds[] = 
{
	{"SRVSVC_NETCHARDEVENUM", NDR_SRVSVC_NETCHARDEVENUM, api_srvsvc_NetCharDevEnum},
	{"SRVSVC_NETCHARDEVGETINFO", NDR_SRVSVC_NETCHARDEVGETINFO, api_srvsvc_NetCharDevGetInfo},
	{"SRVSVC_NETCHARDEVCONTROL", NDR_SRVSVC_NETCHARDEVCONTROL, api_srvsvc_NetCharDevControl},
	{"SRVSVC_NETCHARDEVQENUM", NDR_SRVSVC_NETCHARDEVQENUM, api_srvsvc_NetCharDevQEnum},
	{"SRVSVC_NETCHARDEVQGETINFO", NDR_SRVSVC_NETCHARDEVQGETINFO, api_srvsvc_NetCharDevQGetInfo},
	{"SRVSVC_NETCHARDEVQSETINFO", NDR_SRVSVC_NETCHARDEVQSETINFO, api_srvsvc_NetCharDevQSetInfo},
	{"SRVSVC_NETCHARDEVQPURGE", NDR_SRVSVC_NETCHARDEVQPURGE, api_srvsvc_NetCharDevQPurge},
	{"SRVSVC_NETCHARDEVQPURGESELF", NDR_SRVSVC_NETCHARDEVQPURGESELF, api_srvsvc_NetCharDevQPurgeSelf},
	{"SRVSVC_NETCONNENUM", NDR_SRVSVC_NETCONNENUM, api_srvsvc_NetConnEnum},
	{"SRVSVC_NETFILEENUM", NDR_SRVSVC_NETFILEENUM, api_srvsvc_NetFileEnum},
	{"SRVSVC_NETFILEGETINFO", NDR_SRVSVC_NETFILEGETINFO, api_srvsvc_NetFileGetInfo},
	{"SRVSVC_NETFILECLOSE", NDR_SRVSVC_NETFILECLOSE, api_srvsvc_NetFileClose},
	{"SRVSVC_NETSESSENUM", NDR_SRVSVC_NETSESSENUM, api_srvsvc_NetSessEnum},
	{"SRVSVC_NETSESSDEL", NDR_SRVSVC_NETSESSDEL, api_srvsvc_NetSessDel},
	{"SRVSVC_NETSHAREADD", NDR_SRVSVC_NETSHAREADD, api_srvsvc_NetShareAdd},
	{"SRVSVC_NETSHAREENUMALL", NDR_SRVSVC_NETSHAREENUMALL, api_srvsvc_NetShareEnumAll},
	{"SRVSVC_NETSHAREGETINFO", NDR_SRVSVC_NETSHAREGETINFO, api_srvsvc_NetShareGetInfo},
	{"SRVSVC_NETSHARESETINFO", NDR_SRVSVC_NETSHARESETINFO, api_srvsvc_NetShareSetInfo},
	{"SRVSVC_NETSHAREDEL", NDR_SRVSVC_NETSHAREDEL, api_srvsvc_NetShareDel},
	{"SRVSVC_NETSHAREDELSTICKY", NDR_SRVSVC_NETSHAREDELSTICKY, api_srvsvc_NetShareDelSticky},
	{"SRVSVC_NETSHARECHECK", NDR_SRVSVC_NETSHARECHECK, api_srvsvc_NetShareCheck},
	{"SRVSVC_NETSRVGETINFO", NDR_SRVSVC_NETSRVGETINFO, api_srvsvc_NetSrvGetInfo},
	{"SRVSVC_NETSRVSETINFO", NDR_SRVSVC_NETSRVSETINFO, api_srvsvc_NetSrvSetInfo},
	{"SRVSVC_NETDISKENUM", NDR_SRVSVC_NETDISKENUM, api_srvsvc_NetDiskEnum},
	{"SRVSVC_NETSERVERSTATISTICSGET", NDR_SRVSVC_NETSERVERSTATISTICSGET, api_srvsvc_NetServerStatisticsGet},
	{"SRVSVC_NETTRANSPORTADD", NDR_SRVSVC_NETTRANSPORTADD, api_srvsvc_NetTransportAdd},
	{"SRVSVC_NETTRANSPORTENUM", NDR_SRVSVC_NETTRANSPORTENUM, api_srvsvc_NetTransportEnum},
	{"SRVSVC_NETTRANSPORTDEL", NDR_SRVSVC_NETTRANSPORTDEL, api_srvsvc_NetTransportDel},
	{"SRVSVC_NETREMOTETOD", NDR_SRVSVC_NETREMOTETOD, api_srvsvc_NetRemoteTOD},
	{"SRVSVC_NETSETSERVICEBITS", NDR_SRVSVC_NETSETSERVICEBITS, api_srvsvc_NetSetServiceBits},
	{"SRVSVC_NETPATHTYPE", NDR_SRVSVC_NETPATHTYPE, api_srvsvc_NetPathType},
	{"SRVSVC_NETPATHCANONICALIZE", NDR_SRVSVC_NETPATHCANONICALIZE, api_srvsvc_NetPathCanonicalize},
	{"SRVSVC_NETPATHCOMPARE", NDR_SRVSVC_NETPATHCOMPARE, api_srvsvc_NetPathCompare},
	{"SRVSVC_NETNAMEVALIDATE", NDR_SRVSVC_NETNAMEVALIDATE, api_srvsvc_NetNameValidate},
	{"SRVSVC_NETRPRNAMECANONICALIZE", NDR_SRVSVC_NETRPRNAMECANONICALIZE, api_srvsvc_NETRPRNAMECANONICALIZE},
	{"SRVSVC_NETPRNAMECOMPARE", NDR_SRVSVC_NETPRNAMECOMPARE, api_srvsvc_NetPRNameCompare},
	{"SRVSVC_NETSHAREENUM", NDR_SRVSVC_NETSHAREENUM, api_srvsvc_NetShareEnum},
	{"SRVSVC_NETSHAREDELSTART", NDR_SRVSVC_NETSHAREDELSTART, api_srvsvc_NetShareDelStart},
	{"SRVSVC_NETSHAREDELCOMMIT", NDR_SRVSVC_NETSHAREDELCOMMIT, api_srvsvc_NetShareDelCommit},
	{"SRVSVC_NETGETFILESECURITY", NDR_SRVSVC_NETGETFILESECURITY, api_srvsvc_NetGetFileSecurity},
	{"SRVSVC_NETSETFILESECURITY", NDR_SRVSVC_NETSETFILESECURITY, api_srvsvc_NetSetFileSecurity},
	{"SRVSVC_NETSERVERTRANSPORTADDEX", NDR_SRVSVC_NETSERVERTRANSPORTADDEX, api_srvsvc_NetServerTransportAddEx},
	{"SRVSVC_NETSERVERSETSERVICEBITSEX", NDR_SRVSVC_NETSERVERSETSERVICEBITSEX, api_srvsvc_NetServerSetServiceBitsEx},
	{"SRVSVC_NETRDFSGETVERSION", NDR_SRVSVC_NETRDFSGETVERSION, api_srvsvc_NETRDFSGETVERSION},
	{"SRVSVC_NETRDFSCREATELOCALPARTITION", NDR_SRVSVC_NETRDFSCREATELOCALPARTITION, api_srvsvc_NETRDFSCREATELOCALPARTITION},
	{"SRVSVC_NETRDFSDELETELOCALPARTITION", NDR_SRVSVC_NETRDFSDELETELOCALPARTITION, api_srvsvc_NETRDFSDELETELOCALPARTITION},
	{"SRVSVC_NETRDFSSETLOCALVOLUMESTATE", NDR_SRVSVC_NETRDFSSETLOCALVOLUMESTATE, api_srvsvc_NETRDFSSETLOCALVOLUMESTATE},
	{"SRVSVC_NETRDFSSETSERVERINFO", NDR_SRVSVC_NETRDFSSETSERVERINFO, api_srvsvc_NETRDFSSETSERVERINFO},
	{"SRVSVC_NETRDFSCREATEEXITPOINT", NDR_SRVSVC_NETRDFSCREATEEXITPOINT, api_srvsvc_NETRDFSCREATEEXITPOINT},
	{"SRVSVC_NETRDFSDELETEEXITPOINT", NDR_SRVSVC_NETRDFSDELETEEXITPOINT, api_srvsvc_NETRDFSDELETEEXITPOINT},
	{"SRVSVC_NETRDFSMODIFYPREFIX", NDR_SRVSVC_NETRDFSMODIFYPREFIX, api_srvsvc_NETRDFSMODIFYPREFIX},
	{"SRVSVC_NETRDFSFIXLOCALVOLUME", NDR_SRVSVC_NETRDFSFIXLOCALVOLUME, api_srvsvc_NETRDFSFIXLOCALVOLUME},
	{"SRVSVC_NETRDFSMANAGERREPORTSITEINFO", NDR_SRVSVC_NETRDFSMANAGERREPORTSITEINFO, api_srvsvc_NETRDFSMANAGERREPORTSITEINFO},
	{"SRVSVC_NETRSERVERTRANSPORTDELEX", NDR_SRVSVC_NETRSERVERTRANSPORTDELEX, api_srvsvc_NETRSERVERTRANSPORTDELEX},
};

void srvsvc_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_srvsvc_cmds;
	*n_fns = sizeof(api_srvsvc_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_srvsvc_dispatch(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, const struct ndr_interface_table *table, uint32_t opnum, void *_r)
{
	if (cli->pipes_struct == NULL) {
		return NT_STATUS_INVALID_PARAMETER;
	}

	switch (opnum)
	{
		case NDR_SRVSVC_NETCHARDEVENUM: {
			struct srvsvc_NetCharDevEnum *r = (struct srvsvc_NetCharDevEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetCharDevEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVGETINFO: {
			struct srvsvc_NetCharDevGetInfo *r = (struct srvsvc_NetCharDevGetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union srvsvc_NetCharDevInfo);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetCharDevGetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVCONTROL: {
			struct srvsvc_NetCharDevControl *r = (struct srvsvc_NetCharDevControl *)_r;
			r->out.result = _srvsvc_NetCharDevControl(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVQENUM: {
			struct srvsvc_NetCharDevQEnum *r = (struct srvsvc_NetCharDevQEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetCharDevQEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVQGETINFO: {
			struct srvsvc_NetCharDevQGetInfo *r = (struct srvsvc_NetCharDevQGetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union srvsvc_NetCharDevQInfo);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetCharDevQGetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVQSETINFO: {
			struct srvsvc_NetCharDevQSetInfo *r = (struct srvsvc_NetCharDevQSetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.parm_error = r->in.parm_error;
			r->out.result = _srvsvc_NetCharDevQSetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVQPURGE: {
			struct srvsvc_NetCharDevQPurge *r = (struct srvsvc_NetCharDevQPurge *)_r;
			r->out.result = _srvsvc_NetCharDevQPurge(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCHARDEVQPURGESELF: {
			struct srvsvc_NetCharDevQPurgeSelf *r = (struct srvsvc_NetCharDevQPurgeSelf *)_r;
			r->out.result = _srvsvc_NetCharDevQPurgeSelf(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETCONNENUM: {
			struct srvsvc_NetConnEnum *r = (struct srvsvc_NetConnEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetConnEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETFILEENUM: {
			struct srvsvc_NetFileEnum *r = (struct srvsvc_NetFileEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetFileEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETFILEGETINFO: {
			struct srvsvc_NetFileGetInfo *r = (struct srvsvc_NetFileGetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union srvsvc_NetFileInfo);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetFileGetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETFILECLOSE: {
			struct srvsvc_NetFileClose *r = (struct srvsvc_NetFileClose *)_r;
			r->out.result = _srvsvc_NetFileClose(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSESSENUM: {
			struct srvsvc_NetSessEnum *r = (struct srvsvc_NetSessEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetSessEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSESSDEL: {
			struct srvsvc_NetSessDel *r = (struct srvsvc_NetSessDel *)_r;
			r->out.result = _srvsvc_NetSessDel(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREADD: {
			struct srvsvc_NetShareAdd *r = (struct srvsvc_NetShareAdd *)_r;
			ZERO_STRUCT(r->out);
			r->out.parm_error = r->in.parm_error;
			r->out.result = _srvsvc_NetShareAdd(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREENUMALL: {
			struct srvsvc_NetShareEnumAll *r = (struct srvsvc_NetShareEnumAll *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetShareEnumAll(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREGETINFO: {
			struct srvsvc_NetShareGetInfo *r = (struct srvsvc_NetShareGetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union srvsvc_NetShareInfo);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetShareGetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHARESETINFO: {
			struct srvsvc_NetShareSetInfo *r = (struct srvsvc_NetShareSetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.parm_error = r->in.parm_error;
			r->out.result = _srvsvc_NetShareSetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREDEL: {
			struct srvsvc_NetShareDel *r = (struct srvsvc_NetShareDel *)_r;
			r->out.result = _srvsvc_NetShareDel(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREDELSTICKY: {
			struct srvsvc_NetShareDelSticky *r = (struct srvsvc_NetShareDelSticky *)_r;
			r->out.result = _srvsvc_NetShareDelSticky(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHARECHECK: {
			struct srvsvc_NetShareCheck *r = (struct srvsvc_NetShareCheck *)_r;
			ZERO_STRUCT(r->out);
			r->out.type = talloc_zero(mem_ctx, enum srvsvc_ShareType);
			if (r->out.type == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetShareCheck(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSRVGETINFO: {
			struct srvsvc_NetSrvGetInfo *r = (struct srvsvc_NetSrvGetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, union srvsvc_NetSrvInfo);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetSrvGetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSRVSETINFO: {
			struct srvsvc_NetSrvSetInfo *r = (struct srvsvc_NetSrvSetInfo *)_r;
			ZERO_STRUCT(r->out);
			r->out.parm_error = r->in.parm_error;
			r->out.result = _srvsvc_NetSrvSetInfo(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETDISKENUM: {
			struct srvsvc_NetDiskEnum *r = (struct srvsvc_NetDiskEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = r->in.info;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetDiskEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSERVERSTATISTICSGET: {
			struct srvsvc_NetServerStatisticsGet *r = (struct srvsvc_NetServerStatisticsGet *)_r;
			ZERO_STRUCT(r->out);
			r->out.stats = talloc_zero(mem_ctx, struct srvsvc_Statistics *);
			if (r->out.stats == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetServerStatisticsGet(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETTRANSPORTADD: {
			struct srvsvc_NetTransportAdd *r = (struct srvsvc_NetTransportAdd *)_r;
			r->out.result = _srvsvc_NetTransportAdd(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETTRANSPORTENUM: {
			struct srvsvc_NetTransportEnum *r = (struct srvsvc_NetTransportEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.transports = r->in.transports;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetTransportEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETTRANSPORTDEL: {
			struct srvsvc_NetTransportDel *r = (struct srvsvc_NetTransportDel *)_r;
			r->out.result = _srvsvc_NetTransportDel(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETREMOTETOD: {
			struct srvsvc_NetRemoteTOD *r = (struct srvsvc_NetRemoteTOD *)_r;
			ZERO_STRUCT(r->out);
			r->out.info = talloc_zero(mem_ctx, struct srvsvc_NetRemoteTODInfo *);
			if (r->out.info == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetRemoteTOD(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSETSERVICEBITS: {
			struct srvsvc_NetSetServiceBits *r = (struct srvsvc_NetSetServiceBits *)_r;
			r->out.result = _srvsvc_NetSetServiceBits(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETPATHTYPE: {
			struct srvsvc_NetPathType *r = (struct srvsvc_NetPathType *)_r;
			ZERO_STRUCT(r->out);
			r->out.pathtype = talloc_zero(mem_ctx, uint32_t);
			if (r->out.pathtype == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetPathType(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETPATHCANONICALIZE: {
			struct srvsvc_NetPathCanonicalize *r = (struct srvsvc_NetPathCanonicalize *)_r;
			ZERO_STRUCT(r->out);
			r->out.pathtype = r->in.pathtype;
			r->out.can_path = talloc_zero_array(mem_ctx, uint8_t, r->in.maxbuf);
			if (r->out.can_path == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetPathCanonicalize(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETPATHCOMPARE: {
			struct srvsvc_NetPathCompare *r = (struct srvsvc_NetPathCompare *)_r;
			r->out.result = _srvsvc_NetPathCompare(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETNAMEVALIDATE: {
			struct srvsvc_NetNameValidate *r = (struct srvsvc_NetNameValidate *)_r;
			r->out.result = _srvsvc_NetNameValidate(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRPRNAMECANONICALIZE: {
			struct srvsvc_NETRPRNAMECANONICALIZE *r = (struct srvsvc_NETRPRNAMECANONICALIZE *)_r;
			r->out.result = _srvsvc_NETRPRNAMECANONICALIZE(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETPRNAMECOMPARE: {
			struct srvsvc_NetPRNameCompare *r = (struct srvsvc_NetPRNameCompare *)_r;
			r->out.result = _srvsvc_NetPRNameCompare(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREENUM: {
			struct srvsvc_NetShareEnum *r = (struct srvsvc_NetShareEnum *)_r;
			ZERO_STRUCT(r->out);
			r->out.info_ctr = r->in.info_ctr;
			r->out.resume_handle = r->in.resume_handle;
			r->out.totalentries = talloc_zero(mem_ctx, uint32_t);
			if (r->out.totalentries == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetShareEnum(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREDELSTART: {
			struct srvsvc_NetShareDelStart *r = (struct srvsvc_NetShareDelStart *)_r;
			ZERO_STRUCT(r->out);
			r->out.hnd = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.hnd == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetShareDelStart(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSHAREDELCOMMIT: {
			struct srvsvc_NetShareDelCommit *r = (struct srvsvc_NetShareDelCommit *)_r;
			ZERO_STRUCT(r->out);
			r->out.hnd = r->in.hnd;
			r->out.result = _srvsvc_NetShareDelCommit(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETGETFILESECURITY: {
			struct srvsvc_NetGetFileSecurity *r = (struct srvsvc_NetGetFileSecurity *)_r;
			ZERO_STRUCT(r->out);
			r->out.sd_buf = talloc_zero(mem_ctx, struct sec_desc_buf *);
			if (r->out.sd_buf == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _srvsvc_NetGetFileSecurity(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSETFILESECURITY: {
			struct srvsvc_NetSetFileSecurity *r = (struct srvsvc_NetSetFileSecurity *)_r;
			r->out.result = _srvsvc_NetSetFileSecurity(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSERVERTRANSPORTADDEX: {
			struct srvsvc_NetServerTransportAddEx *r = (struct srvsvc_NetServerTransportAddEx *)_r;
			r->out.result = _srvsvc_NetServerTransportAddEx(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETSERVERSETSERVICEBITSEX: {
			struct srvsvc_NetServerSetServiceBitsEx *r = (struct srvsvc_NetServerSetServiceBitsEx *)_r;
			r->out.result = _srvsvc_NetServerSetServiceBitsEx(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSGETVERSION: {
			struct srvsvc_NETRDFSGETVERSION *r = (struct srvsvc_NETRDFSGETVERSION *)_r;
			r->out.result = _srvsvc_NETRDFSGETVERSION(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSCREATELOCALPARTITION: {
			struct srvsvc_NETRDFSCREATELOCALPARTITION *r = (struct srvsvc_NETRDFSCREATELOCALPARTITION *)_r;
			r->out.result = _srvsvc_NETRDFSCREATELOCALPARTITION(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSDELETELOCALPARTITION: {
			struct srvsvc_NETRDFSDELETELOCALPARTITION *r = (struct srvsvc_NETRDFSDELETELOCALPARTITION *)_r;
			r->out.result = _srvsvc_NETRDFSDELETELOCALPARTITION(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSSETLOCALVOLUMESTATE: {
			struct srvsvc_NETRDFSSETLOCALVOLUMESTATE *r = (struct srvsvc_NETRDFSSETLOCALVOLUMESTATE *)_r;
			r->out.result = _srvsvc_NETRDFSSETLOCALVOLUMESTATE(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSSETSERVERINFO: {
			struct srvsvc_NETRDFSSETSERVERINFO *r = (struct srvsvc_NETRDFSSETSERVERINFO *)_r;
			r->out.result = _srvsvc_NETRDFSSETSERVERINFO(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSCREATEEXITPOINT: {
			struct srvsvc_NETRDFSCREATEEXITPOINT *r = (struct srvsvc_NETRDFSCREATEEXITPOINT *)_r;
			r->out.result = _srvsvc_NETRDFSCREATEEXITPOINT(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSDELETEEXITPOINT: {
			struct srvsvc_NETRDFSDELETEEXITPOINT *r = (struct srvsvc_NETRDFSDELETEEXITPOINT *)_r;
			r->out.result = _srvsvc_NETRDFSDELETEEXITPOINT(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSMODIFYPREFIX: {
			struct srvsvc_NETRDFSMODIFYPREFIX *r = (struct srvsvc_NETRDFSMODIFYPREFIX *)_r;
			r->out.result = _srvsvc_NETRDFSMODIFYPREFIX(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSFIXLOCALVOLUME: {
			struct srvsvc_NETRDFSFIXLOCALVOLUME *r = (struct srvsvc_NETRDFSFIXLOCALVOLUME *)_r;
			r->out.result = _srvsvc_NETRDFSFIXLOCALVOLUME(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRDFSMANAGERREPORTSITEINFO: {
			struct srvsvc_NETRDFSMANAGERREPORTSITEINFO *r = (struct srvsvc_NETRDFSMANAGERREPORTSITEINFO *)_r;
			r->out.result = _srvsvc_NETRDFSMANAGERREPORTSITEINFO(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SRVSVC_NETRSERVERTRANSPORTDELEX: {
			struct srvsvc_NETRSERVERTRANSPORTDELEX *r = (struct srvsvc_NETRSERVERTRANSPORTDELEX *)_r;
			r->out.result = _srvsvc_NETRSERVERTRANSPORTDELEX(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		default:
			return NT_STATUS_NOT_IMPLEMENTED;
	}
}

NTSTATUS rpc_srvsvc_init(void)
{
	return rpc_srv_register(SMB_RPC_INTERFACE_VERSION, "srvsvc", "srvsvc", &ndr_table_srvsvc, api_srvsvc_cmds, sizeof(api_srvsvc_cmds) / sizeof(struct api_struct));
}
