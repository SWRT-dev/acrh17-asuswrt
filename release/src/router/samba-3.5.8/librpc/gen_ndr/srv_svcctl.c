/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "../librpc/gen_ndr/srv_svcctl.h"

static bool api_svcctl_CloseServiceHandle(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_CloseServiceHandle *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CLOSESERVICEHANDLE];

	r = talloc(talloc_tos(), struct svcctl_CloseServiceHandle);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_CloseServiceHandle, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = r->in.handle;
	r->out.result = _svcctl_CloseServiceHandle(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_CloseServiceHandle, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_ControlService(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_ControlService *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CONTROLSERVICE];

	r = talloc(talloc_tos(), struct svcctl_ControlService);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_ControlService, r);
	}

	ZERO_STRUCT(r->out);
	r->out.service_status = talloc_zero(r, struct SERVICE_STATUS);
	if (r->out.service_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_ControlService(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_ControlService, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_DeleteService(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_DeleteService *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_DELETESERVICE];

	r = talloc(talloc_tos(), struct svcctl_DeleteService);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_DeleteService, r);
	}

	r->out.result = _svcctl_DeleteService(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_DeleteService, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_LockServiceDatabase(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_LockServiceDatabase *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_LOCKSERVICEDATABASE];

	r = talloc(talloc_tos(), struct svcctl_LockServiceDatabase);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_LockServiceDatabase, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lock = talloc_zero(r, struct policy_handle);
	if (r->out.lock == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_LockServiceDatabase(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_LockServiceDatabase, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceObjectSecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceObjectSecurity *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICEOBJECTSECURITY];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceObjectSecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceObjectSecurity, r);
	}

	ZERO_STRUCT(r->out);
	r->out.buffer = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.buffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceObjectSecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceObjectSecurity, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_SetServiceObjectSecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_SetServiceObjectSecurity *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_SETSERVICEOBJECTSECURITY];

	r = talloc(talloc_tos(), struct svcctl_SetServiceObjectSecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_SetServiceObjectSecurity, r);
	}

	r->out.result = _svcctl_SetServiceObjectSecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_SetServiceObjectSecurity, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceStatus(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceStatus *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICESTATUS];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceStatus);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceStatus, r);
	}

	ZERO_STRUCT(r->out);
	r->out.service_status = talloc_zero(r, struct SERVICE_STATUS);
	if (r->out.service_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceStatus(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceStatus, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_SetServiceStatus(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_SetServiceStatus *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_SETSERVICESTATUS];

	r = talloc(talloc_tos(), struct svcctl_SetServiceStatus);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_SetServiceStatus, r);
	}

	r->out.result = _svcctl_SetServiceStatus(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_SetServiceStatus, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_UnlockServiceDatabase(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_UnlockServiceDatabase *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_UNLOCKSERVICEDATABASE];

	r = talloc(talloc_tos(), struct svcctl_UnlockServiceDatabase);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_UnlockServiceDatabase, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lock = r->in.lock;
	r->out.result = _svcctl_UnlockServiceDatabase(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_UnlockServiceDatabase, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_NotifyBootConfigStatus(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_NotifyBootConfigStatus *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_NOTIFYBOOTCONFIGSTATUS];

	r = talloc(talloc_tos(), struct svcctl_NotifyBootConfigStatus);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_NotifyBootConfigStatus, r);
	}

	r->out.result = _svcctl_NotifyBootConfigStatus(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_NotifyBootConfigStatus, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_SCSetServiceBitsW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_SCSetServiceBitsW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_SCSETSERVICEBITSW];

	r = talloc(talloc_tos(), struct svcctl_SCSetServiceBitsW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_SCSetServiceBitsW, r);
	}

	r->out.result = _svcctl_SCSetServiceBitsW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_SCSetServiceBitsW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_ChangeServiceConfigW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfigW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CHANGESERVICECONFIGW];

	r = talloc(talloc_tos(), struct svcctl_ChangeServiceConfigW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfigW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.tag_id = talloc_zero(r, uint32_t);
	if (r->out.tag_id == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_ChangeServiceConfigW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfigW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_CreateServiceW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_CreateServiceW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CREATESERVICEW];

	r = talloc(talloc_tos(), struct svcctl_CreateServiceW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_CreateServiceW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.TagId = r->in.TagId;
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_CreateServiceW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_CreateServiceW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_EnumDependentServicesW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_EnumDependentServicesW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_ENUMDEPENDENTSERVICESW];

	r = talloc(talloc_tos(), struct svcctl_EnumDependentServicesW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_EnumDependentServicesW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.service_status = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.service_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.services_returned = talloc_zero(r, uint32_t);
	if (r->out.services_returned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_EnumDependentServicesW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_EnumDependentServicesW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_EnumServicesStatusW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_EnumServicesStatusW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_ENUMSERVICESSTATUSW];

	r = talloc(talloc_tos(), struct svcctl_EnumServicesStatusW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_EnumServicesStatusW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.resume_handle = r->in.resume_handle;
	r->out.service = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.service == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.services_returned = talloc_zero(r, uint32_t);
	if (r->out.services_returned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_EnumServicesStatusW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServicesStatusW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_OpenSCManagerW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_OpenSCManagerW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_OPENSCMANAGERW];

	r = talloc(talloc_tos(), struct svcctl_OpenSCManagerW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_OpenSCManagerW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_OpenSCManagerW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_OpenSCManagerW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_OpenServiceW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_OpenServiceW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_OPENSERVICEW];

	r = talloc(talloc_tos(), struct svcctl_OpenServiceW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_OpenServiceW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_OpenServiceW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_OpenServiceW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceConfigW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfigW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICECONFIGW];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceConfigW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfigW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.query = talloc_zero(r, struct QUERY_SERVICE_CONFIG);
	if (r->out.query == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceConfigW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfigW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceLockStatusW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceLockStatusW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICELOCKSTATUSW];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceLockStatusW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceLockStatusW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lock_status = talloc_zero(r, struct SERVICE_LOCK_STATUS);
	if (r->out.lock_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceLockStatusW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceLockStatusW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_StartServiceW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_StartServiceW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_STARTSERVICEW];

	r = talloc(talloc_tos(), struct svcctl_StartServiceW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_StartServiceW, r);
	}

	r->out.result = _svcctl_StartServiceW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_StartServiceW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_GetServiceDisplayNameW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_GetServiceDisplayNameW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_GETSERVICEDISPLAYNAMEW];

	r = talloc(talloc_tos(), struct svcctl_GetServiceDisplayNameW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceDisplayNameW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.display_name_length = r->in.display_name_length;
	r->out.display_name = talloc_zero(r, const char *);
	if (r->out.display_name == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_GetServiceDisplayNameW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceDisplayNameW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_GetServiceKeyNameW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_GetServiceKeyNameW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_GETSERVICEKEYNAMEW];

	r = talloc(talloc_tos(), struct svcctl_GetServiceKeyNameW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceKeyNameW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.display_name_length = r->in.display_name_length;
	r->out.key_name = talloc_zero(r, const char *);
	if (r->out.key_name == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_GetServiceKeyNameW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceKeyNameW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_SCSetServiceBitsA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_SCSetServiceBitsA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_SCSETSERVICEBITSA];

	r = talloc(talloc_tos(), struct svcctl_SCSetServiceBitsA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_SCSetServiceBitsA, r);
	}

	r->out.result = _svcctl_SCSetServiceBitsA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_SCSetServiceBitsA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_ChangeServiceConfigA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfigA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CHANGESERVICECONFIGA];

	r = talloc(talloc_tos(), struct svcctl_ChangeServiceConfigA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfigA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.tag_id = talloc_zero(r, uint32_t);
	if (r->out.tag_id == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_ChangeServiceConfigA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfigA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_CreateServiceA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_CreateServiceA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CREATESERVICEA];

	r = talloc(talloc_tos(), struct svcctl_CreateServiceA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_CreateServiceA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.TagId = talloc_zero(r, uint32_t);
	if (r->out.TagId == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_CreateServiceA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_CreateServiceA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_EnumDependentServicesA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_EnumDependentServicesA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_ENUMDEPENDENTSERVICESA];

	r = talloc(talloc_tos(), struct svcctl_EnumDependentServicesA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_EnumDependentServicesA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.service_status = talloc_zero(r, struct ENUM_SERVICE_STATUSA);
	if (r->out.service_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.services_returned = talloc_zero(r, uint32_t);
	if (r->out.services_returned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_EnumDependentServicesA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_EnumDependentServicesA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_EnumServicesStatusA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_EnumServicesStatusA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_ENUMSERVICESSTATUSA];

	r = talloc(talloc_tos(), struct svcctl_EnumServicesStatusA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_EnumServicesStatusA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.resume_handle = r->in.resume_handle;
	r->out.service = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.service == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.services_returned = talloc_zero(r, uint32_t);
	if (r->out.services_returned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_EnumServicesStatusA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServicesStatusA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_OpenSCManagerA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_OpenSCManagerA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_OPENSCMANAGERA];

	r = talloc(talloc_tos(), struct svcctl_OpenSCManagerA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_OpenSCManagerA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_OpenSCManagerA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_OpenSCManagerA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_OpenServiceA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_OpenServiceA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_OPENSERVICEA];

	r = talloc(talloc_tos(), struct svcctl_OpenServiceA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_OpenServiceA, r);
	}

	r->out.result = _svcctl_OpenServiceA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_OpenServiceA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceConfigA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfigA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICECONFIGA];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceConfigA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfigA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.query = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.query == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceConfigA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfigA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceLockStatusA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceLockStatusA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICELOCKSTATUSA];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceLockStatusA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceLockStatusA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.lock_status = talloc_zero(r, struct SERVICE_LOCK_STATUS);
	if (r->out.lock_status == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceLockStatusA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceLockStatusA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_StartServiceA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_StartServiceA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_STARTSERVICEA];

	r = talloc(talloc_tos(), struct svcctl_StartServiceA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_StartServiceA, r);
	}

	r->out.result = _svcctl_StartServiceA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_StartServiceA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_GetServiceDisplayNameA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_GetServiceDisplayNameA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_GETSERVICEDISPLAYNAMEA];

	r = talloc(talloc_tos(), struct svcctl_GetServiceDisplayNameA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceDisplayNameA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.display_name_length = r->in.display_name_length;
	r->out.display_name = talloc_zero(r, const char *);
	if (r->out.display_name == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_GetServiceDisplayNameA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceDisplayNameA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_GetServiceKeyNameA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_GetServiceKeyNameA *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_GETSERVICEKEYNAMEA];

	r = talloc(talloc_tos(), struct svcctl_GetServiceKeyNameA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_GetServiceKeyNameA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.display_name_length = r->in.display_name_length;
	r->out.key_name = talloc_zero(r, const char *);
	if (r->out.key_name == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_GetServiceKeyNameA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_GetServiceKeyNameA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_GetCurrentGroupeStateW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_GetCurrentGroupeStateW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_GETCURRENTGROUPESTATEW];

	r = talloc(talloc_tos(), struct svcctl_GetCurrentGroupeStateW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_GetCurrentGroupeStateW, r);
	}

	r->out.result = _svcctl_GetCurrentGroupeStateW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_GetCurrentGroupeStateW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_EnumServiceGroupW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_EnumServiceGroupW *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_ENUMSERVICEGROUPW];

	r = talloc(talloc_tos(), struct svcctl_EnumServiceGroupW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_EnumServiceGroupW, r);
	}

	r->out.result = _svcctl_EnumServiceGroupW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_EnumServiceGroupW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_ChangeServiceConfig2A(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfig2A *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CHANGESERVICECONFIG2A];

	r = talloc(talloc_tos(), struct svcctl_ChangeServiceConfig2A);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfig2A, r);
	}

	r->out.result = _svcctl_ChangeServiceConfig2A(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfig2A, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_ChangeServiceConfig2W(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_ChangeServiceConfig2W *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_CHANGESERVICECONFIG2W];

	r = talloc(talloc_tos(), struct svcctl_ChangeServiceConfig2W);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_ChangeServiceConfig2W, r);
	}

	r->out.result = _svcctl_ChangeServiceConfig2W(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_ChangeServiceConfig2W, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceConfig2A(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfig2A *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICECONFIG2A];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceConfig2A);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfig2A, r);
	}

	ZERO_STRUCT(r->out);
	r->out.buffer = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.buffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceConfig2A(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfig2A, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceConfig2W(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceConfig2W *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICECONFIG2W];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceConfig2W);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceConfig2W, r);
	}

	ZERO_STRUCT(r->out);
	r->out.buffer = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.buffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceConfig2W(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceConfig2W, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_QueryServiceStatusEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_QueryServiceStatusEx *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_QUERYSERVICESTATUSEX];

	r = talloc(talloc_tos(), struct svcctl_QueryServiceStatusEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_QueryServiceStatusEx, r);
	}

	ZERO_STRUCT(r->out);
	r->out.buffer = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.buffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _svcctl_QueryServiceStatusEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_QueryServiceStatusEx, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_EnumServicesStatusExA(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct EnumServicesStatusExA *r;

	call = &ndr_table_svcctl.calls[NDR_ENUMSERVICESSTATUSEXA];

	r = talloc(talloc_tos(), struct EnumServicesStatusExA);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(EnumServicesStatusExA, r);
	}

	ZERO_STRUCT(r->out);
	r->out.resume_handle = r->in.resume_handle;
	r->out.services = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.services == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.service_returned = talloc_zero(r, uint32_t);
	if (r->out.service_returned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.group_name = talloc_zero(r, const char *);
	if (r->out.group_name == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _EnumServicesStatusExA(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(EnumServicesStatusExA, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_EnumServicesStatusExW(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct EnumServicesStatusExW *r;

	call = &ndr_table_svcctl.calls[NDR_ENUMSERVICESSTATUSEXW];

	r = talloc(talloc_tos(), struct EnumServicesStatusExW);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(EnumServicesStatusExW, r);
	}

	ZERO_STRUCT(r->out);
	r->out.resume_handle = r->in.resume_handle;
	r->out.services = talloc_zero_array(r, uint8_t, r->in.offered);
	if (r->out.services == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.needed = talloc_zero(r, uint32_t);
	if (r->out.needed == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.service_returned = talloc_zero(r, uint32_t);
	if (r->out.service_returned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _EnumServicesStatusExW(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(EnumServicesStatusExW, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_svcctl_SCSendTSMessage(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct svcctl_SCSendTSMessage *r;

	call = &ndr_table_svcctl.calls[NDR_SVCCTL_SCSENDTSMESSAGE];

	r = talloc(talloc_tos(), struct svcctl_SCSendTSMessage);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(svcctl_SCSendTSMessage, r);
	}

	r->out.result = _svcctl_SCSendTSMessage(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(svcctl_SCSendTSMessage, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}


/* Tables */
static struct api_struct api_svcctl_cmds[] = 
{
	{"SVCCTL_CLOSESERVICEHANDLE", NDR_SVCCTL_CLOSESERVICEHANDLE, api_svcctl_CloseServiceHandle},
	{"SVCCTL_CONTROLSERVICE", NDR_SVCCTL_CONTROLSERVICE, api_svcctl_ControlService},
	{"SVCCTL_DELETESERVICE", NDR_SVCCTL_DELETESERVICE, api_svcctl_DeleteService},
	{"SVCCTL_LOCKSERVICEDATABASE", NDR_SVCCTL_LOCKSERVICEDATABASE, api_svcctl_LockServiceDatabase},
	{"SVCCTL_QUERYSERVICEOBJECTSECURITY", NDR_SVCCTL_QUERYSERVICEOBJECTSECURITY, api_svcctl_QueryServiceObjectSecurity},
	{"SVCCTL_SETSERVICEOBJECTSECURITY", NDR_SVCCTL_SETSERVICEOBJECTSECURITY, api_svcctl_SetServiceObjectSecurity},
	{"SVCCTL_QUERYSERVICESTATUS", NDR_SVCCTL_QUERYSERVICESTATUS, api_svcctl_QueryServiceStatus},
	{"SVCCTL_SETSERVICESTATUS", NDR_SVCCTL_SETSERVICESTATUS, api_svcctl_SetServiceStatus},
	{"SVCCTL_UNLOCKSERVICEDATABASE", NDR_SVCCTL_UNLOCKSERVICEDATABASE, api_svcctl_UnlockServiceDatabase},
	{"SVCCTL_NOTIFYBOOTCONFIGSTATUS", NDR_SVCCTL_NOTIFYBOOTCONFIGSTATUS, api_svcctl_NotifyBootConfigStatus},
	{"SVCCTL_SCSETSERVICEBITSW", NDR_SVCCTL_SCSETSERVICEBITSW, api_svcctl_SCSetServiceBitsW},
	{"SVCCTL_CHANGESERVICECONFIGW", NDR_SVCCTL_CHANGESERVICECONFIGW, api_svcctl_ChangeServiceConfigW},
	{"SVCCTL_CREATESERVICEW", NDR_SVCCTL_CREATESERVICEW, api_svcctl_CreateServiceW},
	{"SVCCTL_ENUMDEPENDENTSERVICESW", NDR_SVCCTL_ENUMDEPENDENTSERVICESW, api_svcctl_EnumDependentServicesW},
	{"SVCCTL_ENUMSERVICESSTATUSW", NDR_SVCCTL_ENUMSERVICESSTATUSW, api_svcctl_EnumServicesStatusW},
	{"SVCCTL_OPENSCMANAGERW", NDR_SVCCTL_OPENSCMANAGERW, api_svcctl_OpenSCManagerW},
	{"SVCCTL_OPENSERVICEW", NDR_SVCCTL_OPENSERVICEW, api_svcctl_OpenServiceW},
	{"SVCCTL_QUERYSERVICECONFIGW", NDR_SVCCTL_QUERYSERVICECONFIGW, api_svcctl_QueryServiceConfigW},
	{"SVCCTL_QUERYSERVICELOCKSTATUSW", NDR_SVCCTL_QUERYSERVICELOCKSTATUSW, api_svcctl_QueryServiceLockStatusW},
	{"SVCCTL_STARTSERVICEW", NDR_SVCCTL_STARTSERVICEW, api_svcctl_StartServiceW},
	{"SVCCTL_GETSERVICEDISPLAYNAMEW", NDR_SVCCTL_GETSERVICEDISPLAYNAMEW, api_svcctl_GetServiceDisplayNameW},
	{"SVCCTL_GETSERVICEKEYNAMEW", NDR_SVCCTL_GETSERVICEKEYNAMEW, api_svcctl_GetServiceKeyNameW},
	{"SVCCTL_SCSETSERVICEBITSA", NDR_SVCCTL_SCSETSERVICEBITSA, api_svcctl_SCSetServiceBitsA},
	{"SVCCTL_CHANGESERVICECONFIGA", NDR_SVCCTL_CHANGESERVICECONFIGA, api_svcctl_ChangeServiceConfigA},
	{"SVCCTL_CREATESERVICEA", NDR_SVCCTL_CREATESERVICEA, api_svcctl_CreateServiceA},
	{"SVCCTL_ENUMDEPENDENTSERVICESA", NDR_SVCCTL_ENUMDEPENDENTSERVICESA, api_svcctl_EnumDependentServicesA},
	{"SVCCTL_ENUMSERVICESSTATUSA", NDR_SVCCTL_ENUMSERVICESSTATUSA, api_svcctl_EnumServicesStatusA},
	{"SVCCTL_OPENSCMANAGERA", NDR_SVCCTL_OPENSCMANAGERA, api_svcctl_OpenSCManagerA},
	{"SVCCTL_OPENSERVICEA", NDR_SVCCTL_OPENSERVICEA, api_svcctl_OpenServiceA},
	{"SVCCTL_QUERYSERVICECONFIGA", NDR_SVCCTL_QUERYSERVICECONFIGA, api_svcctl_QueryServiceConfigA},
	{"SVCCTL_QUERYSERVICELOCKSTATUSA", NDR_SVCCTL_QUERYSERVICELOCKSTATUSA, api_svcctl_QueryServiceLockStatusA},
	{"SVCCTL_STARTSERVICEA", NDR_SVCCTL_STARTSERVICEA, api_svcctl_StartServiceA},
	{"SVCCTL_GETSERVICEDISPLAYNAMEA", NDR_SVCCTL_GETSERVICEDISPLAYNAMEA, api_svcctl_GetServiceDisplayNameA},
	{"SVCCTL_GETSERVICEKEYNAMEA", NDR_SVCCTL_GETSERVICEKEYNAMEA, api_svcctl_GetServiceKeyNameA},
	{"SVCCTL_GETCURRENTGROUPESTATEW", NDR_SVCCTL_GETCURRENTGROUPESTATEW, api_svcctl_GetCurrentGroupeStateW},
	{"SVCCTL_ENUMSERVICEGROUPW", NDR_SVCCTL_ENUMSERVICEGROUPW, api_svcctl_EnumServiceGroupW},
	{"SVCCTL_CHANGESERVICECONFIG2A", NDR_SVCCTL_CHANGESERVICECONFIG2A, api_svcctl_ChangeServiceConfig2A},
	{"SVCCTL_CHANGESERVICECONFIG2W", NDR_SVCCTL_CHANGESERVICECONFIG2W, api_svcctl_ChangeServiceConfig2W},
	{"SVCCTL_QUERYSERVICECONFIG2A", NDR_SVCCTL_QUERYSERVICECONFIG2A, api_svcctl_QueryServiceConfig2A},
	{"SVCCTL_QUERYSERVICECONFIG2W", NDR_SVCCTL_QUERYSERVICECONFIG2W, api_svcctl_QueryServiceConfig2W},
	{"SVCCTL_QUERYSERVICESTATUSEX", NDR_SVCCTL_QUERYSERVICESTATUSEX, api_svcctl_QueryServiceStatusEx},
	{"ENUMSERVICESSTATUSEXA", NDR_ENUMSERVICESSTATUSEXA, api_EnumServicesStatusExA},
	{"ENUMSERVICESSTATUSEXW", NDR_ENUMSERVICESSTATUSEXW, api_EnumServicesStatusExW},
	{"SVCCTL_SCSENDTSMESSAGE", NDR_SVCCTL_SCSENDTSMESSAGE, api_svcctl_SCSendTSMessage},
};

void svcctl_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_svcctl_cmds;
	*n_fns = sizeof(api_svcctl_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_svcctl_dispatch(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, const struct ndr_interface_table *table, uint32_t opnum, void *_r)
{
	if (cli->pipes_struct == NULL) {
		return NT_STATUS_INVALID_PARAMETER;
	}

	switch (opnum)
	{
		case NDR_SVCCTL_CLOSESERVICEHANDLE: {
			struct svcctl_CloseServiceHandle *r = (struct svcctl_CloseServiceHandle *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = r->in.handle;
			r->out.result = _svcctl_CloseServiceHandle(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CONTROLSERVICE: {
			struct svcctl_ControlService *r = (struct svcctl_ControlService *)_r;
			ZERO_STRUCT(r->out);
			r->out.service_status = talloc_zero(mem_ctx, struct SERVICE_STATUS);
			if (r->out.service_status == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_ControlService(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_DELETESERVICE: {
			struct svcctl_DeleteService *r = (struct svcctl_DeleteService *)_r;
			r->out.result = _svcctl_DeleteService(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_LOCKSERVICEDATABASE: {
			struct svcctl_LockServiceDatabase *r = (struct svcctl_LockServiceDatabase *)_r;
			ZERO_STRUCT(r->out);
			r->out.lock = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.lock == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_LockServiceDatabase(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICEOBJECTSECURITY: {
			struct svcctl_QueryServiceObjectSecurity *r = (struct svcctl_QueryServiceObjectSecurity *)_r;
			ZERO_STRUCT(r->out);
			r->out.buffer = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.buffer == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceObjectSecurity(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_SETSERVICEOBJECTSECURITY: {
			struct svcctl_SetServiceObjectSecurity *r = (struct svcctl_SetServiceObjectSecurity *)_r;
			r->out.result = _svcctl_SetServiceObjectSecurity(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICESTATUS: {
			struct svcctl_QueryServiceStatus *r = (struct svcctl_QueryServiceStatus *)_r;
			ZERO_STRUCT(r->out);
			r->out.service_status = talloc_zero(mem_ctx, struct SERVICE_STATUS);
			if (r->out.service_status == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceStatus(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_SETSERVICESTATUS: {
			struct svcctl_SetServiceStatus *r = (struct svcctl_SetServiceStatus *)_r;
			r->out.result = _svcctl_SetServiceStatus(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_UNLOCKSERVICEDATABASE: {
			struct svcctl_UnlockServiceDatabase *r = (struct svcctl_UnlockServiceDatabase *)_r;
			ZERO_STRUCT(r->out);
			r->out.lock = r->in.lock;
			r->out.result = _svcctl_UnlockServiceDatabase(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_NOTIFYBOOTCONFIGSTATUS: {
			struct svcctl_NotifyBootConfigStatus *r = (struct svcctl_NotifyBootConfigStatus *)_r;
			r->out.result = _svcctl_NotifyBootConfigStatus(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_SCSETSERVICEBITSW: {
			struct svcctl_SCSetServiceBitsW *r = (struct svcctl_SCSetServiceBitsW *)_r;
			r->out.result = _svcctl_SCSetServiceBitsW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CHANGESERVICECONFIGW: {
			struct svcctl_ChangeServiceConfigW *r = (struct svcctl_ChangeServiceConfigW *)_r;
			ZERO_STRUCT(r->out);
			r->out.tag_id = talloc_zero(mem_ctx, uint32_t);
			if (r->out.tag_id == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_ChangeServiceConfigW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CREATESERVICEW: {
			struct svcctl_CreateServiceW *r = (struct svcctl_CreateServiceW *)_r;
			ZERO_STRUCT(r->out);
			r->out.TagId = r->in.TagId;
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_CreateServiceW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_ENUMDEPENDENTSERVICESW: {
			struct svcctl_EnumDependentServicesW *r = (struct svcctl_EnumDependentServicesW *)_r;
			ZERO_STRUCT(r->out);
			r->out.service_status = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.service_status == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.services_returned = talloc_zero(mem_ctx, uint32_t);
			if (r->out.services_returned == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_EnumDependentServicesW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_ENUMSERVICESSTATUSW: {
			struct svcctl_EnumServicesStatusW *r = (struct svcctl_EnumServicesStatusW *)_r;
			ZERO_STRUCT(r->out);
			r->out.resume_handle = r->in.resume_handle;
			r->out.service = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.service == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.services_returned = talloc_zero(mem_ctx, uint32_t);
			if (r->out.services_returned == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_EnumServicesStatusW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_OPENSCMANAGERW: {
			struct svcctl_OpenSCManagerW *r = (struct svcctl_OpenSCManagerW *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_OpenSCManagerW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_OPENSERVICEW: {
			struct svcctl_OpenServiceW *r = (struct svcctl_OpenServiceW *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_OpenServiceW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICECONFIGW: {
			struct svcctl_QueryServiceConfigW *r = (struct svcctl_QueryServiceConfigW *)_r;
			ZERO_STRUCT(r->out);
			r->out.query = talloc_zero(mem_ctx, struct QUERY_SERVICE_CONFIG);
			if (r->out.query == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceConfigW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICELOCKSTATUSW: {
			struct svcctl_QueryServiceLockStatusW *r = (struct svcctl_QueryServiceLockStatusW *)_r;
			ZERO_STRUCT(r->out);
			r->out.lock_status = talloc_zero(mem_ctx, struct SERVICE_LOCK_STATUS);
			if (r->out.lock_status == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceLockStatusW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_STARTSERVICEW: {
			struct svcctl_StartServiceW *r = (struct svcctl_StartServiceW *)_r;
			r->out.result = _svcctl_StartServiceW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_GETSERVICEDISPLAYNAMEW: {
			struct svcctl_GetServiceDisplayNameW *r = (struct svcctl_GetServiceDisplayNameW *)_r;
			ZERO_STRUCT(r->out);
			r->out.display_name_length = r->in.display_name_length;
			r->out.display_name = talloc_zero(mem_ctx, const char *);
			if (r->out.display_name == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_GetServiceDisplayNameW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_GETSERVICEKEYNAMEW: {
			struct svcctl_GetServiceKeyNameW *r = (struct svcctl_GetServiceKeyNameW *)_r;
			ZERO_STRUCT(r->out);
			r->out.display_name_length = r->in.display_name_length;
			r->out.key_name = talloc_zero(mem_ctx, const char *);
			if (r->out.key_name == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_GetServiceKeyNameW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_SCSETSERVICEBITSA: {
			struct svcctl_SCSetServiceBitsA *r = (struct svcctl_SCSetServiceBitsA *)_r;
			r->out.result = _svcctl_SCSetServiceBitsA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CHANGESERVICECONFIGA: {
			struct svcctl_ChangeServiceConfigA *r = (struct svcctl_ChangeServiceConfigA *)_r;
			ZERO_STRUCT(r->out);
			r->out.tag_id = talloc_zero(mem_ctx, uint32_t);
			if (r->out.tag_id == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_ChangeServiceConfigA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CREATESERVICEA: {
			struct svcctl_CreateServiceA *r = (struct svcctl_CreateServiceA *)_r;
			ZERO_STRUCT(r->out);
			r->out.TagId = talloc_zero(mem_ctx, uint32_t);
			if (r->out.TagId == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_CreateServiceA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_ENUMDEPENDENTSERVICESA: {
			struct svcctl_EnumDependentServicesA *r = (struct svcctl_EnumDependentServicesA *)_r;
			ZERO_STRUCT(r->out);
			r->out.service_status = talloc_zero(mem_ctx, struct ENUM_SERVICE_STATUSA);
			if (r->out.service_status == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.services_returned = talloc_zero(mem_ctx, uint32_t);
			if (r->out.services_returned == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_EnumDependentServicesA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_ENUMSERVICESSTATUSA: {
			struct svcctl_EnumServicesStatusA *r = (struct svcctl_EnumServicesStatusA *)_r;
			ZERO_STRUCT(r->out);
			r->out.resume_handle = r->in.resume_handle;
			r->out.service = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.service == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.services_returned = talloc_zero(mem_ctx, uint32_t);
			if (r->out.services_returned == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_EnumServicesStatusA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_OPENSCMANAGERA: {
			struct svcctl_OpenSCManagerA *r = (struct svcctl_OpenSCManagerA *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_OpenSCManagerA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_OPENSERVICEA: {
			struct svcctl_OpenServiceA *r = (struct svcctl_OpenServiceA *)_r;
			r->out.result = _svcctl_OpenServiceA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICECONFIGA: {
			struct svcctl_QueryServiceConfigA *r = (struct svcctl_QueryServiceConfigA *)_r;
			ZERO_STRUCT(r->out);
			r->out.query = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.query == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceConfigA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICELOCKSTATUSA: {
			struct svcctl_QueryServiceLockStatusA *r = (struct svcctl_QueryServiceLockStatusA *)_r;
			ZERO_STRUCT(r->out);
			r->out.lock_status = talloc_zero(mem_ctx, struct SERVICE_LOCK_STATUS);
			if (r->out.lock_status == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceLockStatusA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_STARTSERVICEA: {
			struct svcctl_StartServiceA *r = (struct svcctl_StartServiceA *)_r;
			r->out.result = _svcctl_StartServiceA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_GETSERVICEDISPLAYNAMEA: {
			struct svcctl_GetServiceDisplayNameA *r = (struct svcctl_GetServiceDisplayNameA *)_r;
			ZERO_STRUCT(r->out);
			r->out.display_name_length = r->in.display_name_length;
			r->out.display_name = talloc_zero(mem_ctx, const char *);
			if (r->out.display_name == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_GetServiceDisplayNameA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_GETSERVICEKEYNAMEA: {
			struct svcctl_GetServiceKeyNameA *r = (struct svcctl_GetServiceKeyNameA *)_r;
			ZERO_STRUCT(r->out);
			r->out.display_name_length = r->in.display_name_length;
			r->out.key_name = talloc_zero(mem_ctx, const char *);
			if (r->out.key_name == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_GetServiceKeyNameA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_GETCURRENTGROUPESTATEW: {
			struct svcctl_GetCurrentGroupeStateW *r = (struct svcctl_GetCurrentGroupeStateW *)_r;
			r->out.result = _svcctl_GetCurrentGroupeStateW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_ENUMSERVICEGROUPW: {
			struct svcctl_EnumServiceGroupW *r = (struct svcctl_EnumServiceGroupW *)_r;
			r->out.result = _svcctl_EnumServiceGroupW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CHANGESERVICECONFIG2A: {
			struct svcctl_ChangeServiceConfig2A *r = (struct svcctl_ChangeServiceConfig2A *)_r;
			r->out.result = _svcctl_ChangeServiceConfig2A(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_CHANGESERVICECONFIG2W: {
			struct svcctl_ChangeServiceConfig2W *r = (struct svcctl_ChangeServiceConfig2W *)_r;
			r->out.result = _svcctl_ChangeServiceConfig2W(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICECONFIG2A: {
			struct svcctl_QueryServiceConfig2A *r = (struct svcctl_QueryServiceConfig2A *)_r;
			ZERO_STRUCT(r->out);
			r->out.buffer = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.buffer == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceConfig2A(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICECONFIG2W: {
			struct svcctl_QueryServiceConfig2W *r = (struct svcctl_QueryServiceConfig2W *)_r;
			ZERO_STRUCT(r->out);
			r->out.buffer = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.buffer == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceConfig2W(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_QUERYSERVICESTATUSEX: {
			struct svcctl_QueryServiceStatusEx *r = (struct svcctl_QueryServiceStatusEx *)_r;
			ZERO_STRUCT(r->out);
			r->out.buffer = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.buffer == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _svcctl_QueryServiceStatusEx(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_ENUMSERVICESSTATUSEXA: {
			struct EnumServicesStatusExA *r = (struct EnumServicesStatusExA *)_r;
			ZERO_STRUCT(r->out);
			r->out.resume_handle = r->in.resume_handle;
			r->out.services = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.services == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.service_returned = talloc_zero(mem_ctx, uint32_t);
			if (r->out.service_returned == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.group_name = talloc_zero(mem_ctx, const char *);
			if (r->out.group_name == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _EnumServicesStatusExA(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_ENUMSERVICESSTATUSEXW: {
			struct EnumServicesStatusExW *r = (struct EnumServicesStatusExW *)_r;
			ZERO_STRUCT(r->out);
			r->out.resume_handle = r->in.resume_handle;
			r->out.services = talloc_zero_array(mem_ctx, uint8_t, r->in.offered);
			if (r->out.services == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.needed = talloc_zero(mem_ctx, uint32_t);
			if (r->out.needed == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.service_returned = talloc_zero(mem_ctx, uint32_t);
			if (r->out.service_returned == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _EnumServicesStatusExW(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_SVCCTL_SCSENDTSMESSAGE: {
			struct svcctl_SCSendTSMessage *r = (struct svcctl_SCSendTSMessage *)_r;
			r->out.result = _svcctl_SCSendTSMessage(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		default:
			return NT_STATUS_NOT_IMPLEMENTED;
	}
}

NTSTATUS rpc_svcctl_init(void)
{
	return rpc_srv_register(SMB_RPC_INTERFACE_VERSION, "svcctl", "svcctl", &ndr_table_svcctl, api_svcctl_cmds, sizeof(api_svcctl_cmds) / sizeof(struct api_struct));
}
