/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "../librpc/gen_ndr/srv_winreg.h"

static bool api_winreg_OpenHKCR(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKCR *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKCR];

	r = talloc(talloc_tos(), struct winreg_OpenHKCR);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKCR, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKCR(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKCR, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKCU(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKCU *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKCU];

	r = talloc(talloc_tos(), struct winreg_OpenHKCU);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKCU, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKCU(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKCU, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKLM(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKLM *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKLM];

	r = talloc(talloc_tos(), struct winreg_OpenHKLM);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKLM, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKLM(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKLM, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKPD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKPD *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKPD];

	r = talloc(talloc_tos(), struct winreg_OpenHKPD);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKPD, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKPD(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKPD, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKU(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKU *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKU];

	r = talloc(talloc_tos(), struct winreg_OpenHKU);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKU, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKU(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKU, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_CloseKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_CloseKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_CLOSEKEY];

	r = talloc(talloc_tos(), struct winreg_CloseKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_CloseKey, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = r->in.handle;
	r->out.result = _winreg_CloseKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_CloseKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_CreateKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_CreateKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_CREATEKEY];

	r = talloc(talloc_tos(), struct winreg_CreateKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_CreateKey, r);
	}

	ZERO_STRUCT(r->out);
	r->out.action_taken = r->in.action_taken;
	r->out.new_handle = talloc_zero(r, struct policy_handle);
	if (r->out.new_handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_CreateKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_CreateKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_DeleteKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_DeleteKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_DELETEKEY];

	r = talloc(talloc_tos(), struct winreg_DeleteKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_DeleteKey, r);
	}

	r->out.result = _winreg_DeleteKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_DeleteKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_DeleteValue(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_DeleteValue *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_DELETEVALUE];

	r = talloc(talloc_tos(), struct winreg_DeleteValue);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_DeleteValue, r);
	}

	r->out.result = _winreg_DeleteValue(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_DeleteValue, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_EnumKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_EnumKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_ENUMKEY];

	r = talloc(talloc_tos(), struct winreg_EnumKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_EnumKey, r);
	}

	ZERO_STRUCT(r->out);
	r->out.name = r->in.name;
	r->out.keyclass = r->in.keyclass;
	r->out.last_changed_time = r->in.last_changed_time;
	r->out.result = _winreg_EnumKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_EnumKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_EnumValue(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_EnumValue *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_ENUMVALUE];

	r = talloc(talloc_tos(), struct winreg_EnumValue);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_EnumValue, r);
	}

	ZERO_STRUCT(r->out);
	r->out.name = r->in.name;
	r->out.type = r->in.type;
	r->out.value = r->in.value;
	r->out.size = r->in.size;
	r->out.length = r->in.length;
	r->out.result = _winreg_EnumValue(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_EnumValue, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_FlushKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_FlushKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_FLUSHKEY];

	r = talloc(talloc_tos(), struct winreg_FlushKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_FlushKey, r);
	}

	r->out.result = _winreg_FlushKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_FlushKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_GetKeySecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_GetKeySecurity *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_GETKEYSECURITY];

	r = talloc(talloc_tos(), struct winreg_GetKeySecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_GetKeySecurity, r);
	}

	ZERO_STRUCT(r->out);
	r->out.sd = r->in.sd;
	r->out.result = _winreg_GetKeySecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_GetKeySecurity, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_LoadKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_LoadKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_LOADKEY];

	r = talloc(talloc_tos(), struct winreg_LoadKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_LoadKey, r);
	}

	r->out.result = _winreg_LoadKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_LoadKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_NotifyChangeKeyValue(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_NotifyChangeKeyValue *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_NOTIFYCHANGEKEYVALUE];

	r = talloc(talloc_tos(), struct winreg_NotifyChangeKeyValue);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_NotifyChangeKeyValue, r);
	}

	r->out.result = _winreg_NotifyChangeKeyValue(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_NotifyChangeKeyValue, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENKEY];

	r = talloc(talloc_tos(), struct winreg_OpenKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenKey, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_QueryInfoKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_QueryInfoKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_QUERYINFOKEY];

	r = talloc(talloc_tos(), struct winreg_QueryInfoKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_QueryInfoKey, r);
	}

	ZERO_STRUCT(r->out);
	r->out.classname = r->in.classname;
	r->out.num_subkeys = talloc_zero(r, uint32_t);
	if (r->out.num_subkeys == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.max_subkeylen = talloc_zero(r, uint32_t);
	if (r->out.max_subkeylen == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.max_classlen = talloc_zero(r, uint32_t);
	if (r->out.max_classlen == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.num_values = talloc_zero(r, uint32_t);
	if (r->out.num_values == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.max_valnamelen = talloc_zero(r, uint32_t);
	if (r->out.max_valnamelen == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.max_valbufsize = talloc_zero(r, uint32_t);
	if (r->out.max_valbufsize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.secdescsize = talloc_zero(r, uint32_t);
	if (r->out.secdescsize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.last_changed_time = talloc_zero(r, NTTIME);
	if (r->out.last_changed_time == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_QueryInfoKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_QueryInfoKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_QueryValue(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_QueryValue *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_QUERYVALUE];

	r = talloc(talloc_tos(), struct winreg_QueryValue);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_QueryValue, r);
	}

	ZERO_STRUCT(r->out);
	r->out.type = r->in.type;
	r->out.data = r->in.data;
	r->out.data_size = r->in.data_size;
	r->out.data_length = r->in.data_length;
	r->out.result = _winreg_QueryValue(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_QueryValue, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_ReplaceKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_ReplaceKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_REPLACEKEY];

	r = talloc(talloc_tos(), struct winreg_ReplaceKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_ReplaceKey, r);
	}

	r->out.result = _winreg_ReplaceKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_ReplaceKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_RestoreKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_RestoreKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_RESTOREKEY];

	r = talloc(talloc_tos(), struct winreg_RestoreKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_RestoreKey, r);
	}

	r->out.result = _winreg_RestoreKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_RestoreKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_SaveKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_SaveKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_SAVEKEY];

	r = talloc(talloc_tos(), struct winreg_SaveKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_SaveKey, r);
	}

	r->out.result = _winreg_SaveKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_SaveKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_SetKeySecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_SetKeySecurity *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_SETKEYSECURITY];

	r = talloc(talloc_tos(), struct winreg_SetKeySecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_SetKeySecurity, r);
	}

	r->out.result = _winreg_SetKeySecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_SetKeySecurity, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_SetValue(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_SetValue *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_SETVALUE];

	r = talloc(talloc_tos(), struct winreg_SetValue);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_SetValue, r);
	}

	r->out.result = _winreg_SetValue(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_SetValue, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_UnLoadKey(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_UnLoadKey *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_UNLOADKEY];

	r = talloc(talloc_tos(), struct winreg_UnLoadKey);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_UnLoadKey, r);
	}

	r->out.result = _winreg_UnLoadKey(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_UnLoadKey, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_InitiateSystemShutdown(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_InitiateSystemShutdown *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_INITIATESYSTEMSHUTDOWN];

	r = talloc(talloc_tos(), struct winreg_InitiateSystemShutdown);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_InitiateSystemShutdown, r);
	}

	r->out.result = _winreg_InitiateSystemShutdown(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_InitiateSystemShutdown, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_AbortSystemShutdown(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_AbortSystemShutdown *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_ABORTSYSTEMSHUTDOWN];

	r = talloc(talloc_tos(), struct winreg_AbortSystemShutdown);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_AbortSystemShutdown, r);
	}

	r->out.result = _winreg_AbortSystemShutdown(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_AbortSystemShutdown, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_GetVersion(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_GetVersion *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_GETVERSION];

	r = talloc(talloc_tos(), struct winreg_GetVersion);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_GetVersion, r);
	}

	ZERO_STRUCT(r->out);
	r->out.version = talloc_zero(r, uint32_t);
	if (r->out.version == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_GetVersion(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_GetVersion, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKCC(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKCC *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKCC];

	r = talloc(talloc_tos(), struct winreg_OpenHKCC);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKCC, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKCC(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKCC, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKDD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKDD *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKDD];

	r = talloc(talloc_tos(), struct winreg_OpenHKDD);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKDD, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKDD(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKDD, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_QueryMultipleValues(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_QueryMultipleValues *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_QUERYMULTIPLEVALUES];

	r = talloc(talloc_tos(), struct winreg_QueryMultipleValues);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_QueryMultipleValues, r);
	}

	ZERO_STRUCT(r->out);
	r->out.values = r->in.values;
	r->out.buffer = r->in.buffer;
	r->out.buffer_size = r->in.buffer_size;
	r->out.result = _winreg_QueryMultipleValues(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_QueryMultipleValues, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_InitiateSystemShutdownEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_InitiateSystemShutdownEx *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_INITIATESYSTEMSHUTDOWNEX];

	r = talloc(talloc_tos(), struct winreg_InitiateSystemShutdownEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_InitiateSystemShutdownEx, r);
	}

	r->out.result = _winreg_InitiateSystemShutdownEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_InitiateSystemShutdownEx, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_SaveKeyEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_SaveKeyEx *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_SAVEKEYEX];

	r = talloc(talloc_tos(), struct winreg_SaveKeyEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_SaveKeyEx, r);
	}

	r->out.result = _winreg_SaveKeyEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_SaveKeyEx, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKPT(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKPT *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKPT];

	r = talloc(talloc_tos(), struct winreg_OpenHKPT);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKPT, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKPT(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKPT, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_OpenHKPN(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_OpenHKPN *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_OPENHKPN];

	r = talloc(talloc_tos(), struct winreg_OpenHKPN);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_OpenHKPN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _winreg_OpenHKPN(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_OpenHKPN, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_winreg_QueryMultipleValues2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct winreg_QueryMultipleValues2 *r;

	call = &ndr_table_winreg.calls[NDR_WINREG_QUERYMULTIPLEVALUES2];

	r = talloc(talloc_tos(), struct winreg_QueryMultipleValues2);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(winreg_QueryMultipleValues2, r);
	}

	r->out.result = _winreg_QueryMultipleValues2(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(winreg_QueryMultipleValues2, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}


/* Tables */
static struct api_struct api_winreg_cmds[] = 
{
	{"WINREG_OPENHKCR", NDR_WINREG_OPENHKCR, api_winreg_OpenHKCR},
	{"WINREG_OPENHKCU", NDR_WINREG_OPENHKCU, api_winreg_OpenHKCU},
	{"WINREG_OPENHKLM", NDR_WINREG_OPENHKLM, api_winreg_OpenHKLM},
	{"WINREG_OPENHKPD", NDR_WINREG_OPENHKPD, api_winreg_OpenHKPD},
	{"WINREG_OPENHKU", NDR_WINREG_OPENHKU, api_winreg_OpenHKU},
	{"WINREG_CLOSEKEY", NDR_WINREG_CLOSEKEY, api_winreg_CloseKey},
	{"WINREG_CREATEKEY", NDR_WINREG_CREATEKEY, api_winreg_CreateKey},
	{"WINREG_DELETEKEY", NDR_WINREG_DELETEKEY, api_winreg_DeleteKey},
	{"WINREG_DELETEVALUE", NDR_WINREG_DELETEVALUE, api_winreg_DeleteValue},
	{"WINREG_ENUMKEY", NDR_WINREG_ENUMKEY, api_winreg_EnumKey},
	{"WINREG_ENUMVALUE", NDR_WINREG_ENUMVALUE, api_winreg_EnumValue},
	{"WINREG_FLUSHKEY", NDR_WINREG_FLUSHKEY, api_winreg_FlushKey},
	{"WINREG_GETKEYSECURITY", NDR_WINREG_GETKEYSECURITY, api_winreg_GetKeySecurity},
	{"WINREG_LOADKEY", NDR_WINREG_LOADKEY, api_winreg_LoadKey},
	{"WINREG_NOTIFYCHANGEKEYVALUE", NDR_WINREG_NOTIFYCHANGEKEYVALUE, api_winreg_NotifyChangeKeyValue},
	{"WINREG_OPENKEY", NDR_WINREG_OPENKEY, api_winreg_OpenKey},
	{"WINREG_QUERYINFOKEY", NDR_WINREG_QUERYINFOKEY, api_winreg_QueryInfoKey},
	{"WINREG_QUERYVALUE", NDR_WINREG_QUERYVALUE, api_winreg_QueryValue},
	{"WINREG_REPLACEKEY", NDR_WINREG_REPLACEKEY, api_winreg_ReplaceKey},
	{"WINREG_RESTOREKEY", NDR_WINREG_RESTOREKEY, api_winreg_RestoreKey},
	{"WINREG_SAVEKEY", NDR_WINREG_SAVEKEY, api_winreg_SaveKey},
	{"WINREG_SETKEYSECURITY", NDR_WINREG_SETKEYSECURITY, api_winreg_SetKeySecurity},
	{"WINREG_SETVALUE", NDR_WINREG_SETVALUE, api_winreg_SetValue},
	{"WINREG_UNLOADKEY", NDR_WINREG_UNLOADKEY, api_winreg_UnLoadKey},
	{"WINREG_INITIATESYSTEMSHUTDOWN", NDR_WINREG_INITIATESYSTEMSHUTDOWN, api_winreg_InitiateSystemShutdown},
	{"WINREG_ABORTSYSTEMSHUTDOWN", NDR_WINREG_ABORTSYSTEMSHUTDOWN, api_winreg_AbortSystemShutdown},
	{"WINREG_GETVERSION", NDR_WINREG_GETVERSION, api_winreg_GetVersion},
	{"WINREG_OPENHKCC", NDR_WINREG_OPENHKCC, api_winreg_OpenHKCC},
	{"WINREG_OPENHKDD", NDR_WINREG_OPENHKDD, api_winreg_OpenHKDD},
	{"WINREG_QUERYMULTIPLEVALUES", NDR_WINREG_QUERYMULTIPLEVALUES, api_winreg_QueryMultipleValues},
	{"WINREG_INITIATESYSTEMSHUTDOWNEX", NDR_WINREG_INITIATESYSTEMSHUTDOWNEX, api_winreg_InitiateSystemShutdownEx},
	{"WINREG_SAVEKEYEX", NDR_WINREG_SAVEKEYEX, api_winreg_SaveKeyEx},
	{"WINREG_OPENHKPT", NDR_WINREG_OPENHKPT, api_winreg_OpenHKPT},
	{"WINREG_OPENHKPN", NDR_WINREG_OPENHKPN, api_winreg_OpenHKPN},
	{"WINREG_QUERYMULTIPLEVALUES2", NDR_WINREG_QUERYMULTIPLEVALUES2, api_winreg_QueryMultipleValues2},
};

void winreg_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_winreg_cmds;
	*n_fns = sizeof(api_winreg_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_winreg_dispatch(struct rpc_pipe_client *cli, TALLOC_CTX *mem_ctx, const struct ndr_interface_table *table, uint32_t opnum, void *_r)
{
	if (cli->pipes_struct == NULL) {
		return NT_STATUS_INVALID_PARAMETER;
	}

	switch (opnum)
	{
		case NDR_WINREG_OPENHKCR: {
			struct winreg_OpenHKCR *r = (struct winreg_OpenHKCR *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKCR(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKCU: {
			struct winreg_OpenHKCU *r = (struct winreg_OpenHKCU *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKCU(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKLM: {
			struct winreg_OpenHKLM *r = (struct winreg_OpenHKLM *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKLM(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKPD: {
			struct winreg_OpenHKPD *r = (struct winreg_OpenHKPD *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKPD(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKU: {
			struct winreg_OpenHKU *r = (struct winreg_OpenHKU *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKU(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_CLOSEKEY: {
			struct winreg_CloseKey *r = (struct winreg_CloseKey *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = r->in.handle;
			r->out.result = _winreg_CloseKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_CREATEKEY: {
			struct winreg_CreateKey *r = (struct winreg_CreateKey *)_r;
			ZERO_STRUCT(r->out);
			r->out.action_taken = r->in.action_taken;
			r->out.new_handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.new_handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_CreateKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_DELETEKEY: {
			struct winreg_DeleteKey *r = (struct winreg_DeleteKey *)_r;
			r->out.result = _winreg_DeleteKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_DELETEVALUE: {
			struct winreg_DeleteValue *r = (struct winreg_DeleteValue *)_r;
			r->out.result = _winreg_DeleteValue(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_ENUMKEY: {
			struct winreg_EnumKey *r = (struct winreg_EnumKey *)_r;
			ZERO_STRUCT(r->out);
			r->out.name = r->in.name;
			r->out.keyclass = r->in.keyclass;
			r->out.last_changed_time = r->in.last_changed_time;
			r->out.result = _winreg_EnumKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_ENUMVALUE: {
			struct winreg_EnumValue *r = (struct winreg_EnumValue *)_r;
			ZERO_STRUCT(r->out);
			r->out.name = r->in.name;
			r->out.type = r->in.type;
			r->out.value = r->in.value;
			r->out.size = r->in.size;
			r->out.length = r->in.length;
			r->out.result = _winreg_EnumValue(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_FLUSHKEY: {
			struct winreg_FlushKey *r = (struct winreg_FlushKey *)_r;
			r->out.result = _winreg_FlushKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_GETKEYSECURITY: {
			struct winreg_GetKeySecurity *r = (struct winreg_GetKeySecurity *)_r;
			ZERO_STRUCT(r->out);
			r->out.sd = r->in.sd;
			r->out.result = _winreg_GetKeySecurity(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_LOADKEY: {
			struct winreg_LoadKey *r = (struct winreg_LoadKey *)_r;
			r->out.result = _winreg_LoadKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_NOTIFYCHANGEKEYVALUE: {
			struct winreg_NotifyChangeKeyValue *r = (struct winreg_NotifyChangeKeyValue *)_r;
			r->out.result = _winreg_NotifyChangeKeyValue(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENKEY: {
			struct winreg_OpenKey *r = (struct winreg_OpenKey *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_QUERYINFOKEY: {
			struct winreg_QueryInfoKey *r = (struct winreg_QueryInfoKey *)_r;
			ZERO_STRUCT(r->out);
			r->out.classname = r->in.classname;
			r->out.num_subkeys = talloc_zero(mem_ctx, uint32_t);
			if (r->out.num_subkeys == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.max_subkeylen = talloc_zero(mem_ctx, uint32_t);
			if (r->out.max_subkeylen == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.max_classlen = talloc_zero(mem_ctx, uint32_t);
			if (r->out.max_classlen == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.num_values = talloc_zero(mem_ctx, uint32_t);
			if (r->out.num_values == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.max_valnamelen = talloc_zero(mem_ctx, uint32_t);
			if (r->out.max_valnamelen == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.max_valbufsize = talloc_zero(mem_ctx, uint32_t);
			if (r->out.max_valbufsize == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.secdescsize = talloc_zero(mem_ctx, uint32_t);
			if (r->out.secdescsize == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.last_changed_time = talloc_zero(mem_ctx, NTTIME);
			if (r->out.last_changed_time == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_QueryInfoKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_QUERYVALUE: {
			struct winreg_QueryValue *r = (struct winreg_QueryValue *)_r;
			ZERO_STRUCT(r->out);
			r->out.type = r->in.type;
			r->out.data = r->in.data;
			r->out.data_size = r->in.data_size;
			r->out.data_length = r->in.data_length;
			r->out.result = _winreg_QueryValue(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_REPLACEKEY: {
			struct winreg_ReplaceKey *r = (struct winreg_ReplaceKey *)_r;
			r->out.result = _winreg_ReplaceKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_RESTOREKEY: {
			struct winreg_RestoreKey *r = (struct winreg_RestoreKey *)_r;
			r->out.result = _winreg_RestoreKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_SAVEKEY: {
			struct winreg_SaveKey *r = (struct winreg_SaveKey *)_r;
			r->out.result = _winreg_SaveKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_SETKEYSECURITY: {
			struct winreg_SetKeySecurity *r = (struct winreg_SetKeySecurity *)_r;
			r->out.result = _winreg_SetKeySecurity(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_SETVALUE: {
			struct winreg_SetValue *r = (struct winreg_SetValue *)_r;
			r->out.result = _winreg_SetValue(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_UNLOADKEY: {
			struct winreg_UnLoadKey *r = (struct winreg_UnLoadKey *)_r;
			r->out.result = _winreg_UnLoadKey(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_INITIATESYSTEMSHUTDOWN: {
			struct winreg_InitiateSystemShutdown *r = (struct winreg_InitiateSystemShutdown *)_r;
			r->out.result = _winreg_InitiateSystemShutdown(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_ABORTSYSTEMSHUTDOWN: {
			struct winreg_AbortSystemShutdown *r = (struct winreg_AbortSystemShutdown *)_r;
			r->out.result = _winreg_AbortSystemShutdown(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_GETVERSION: {
			struct winreg_GetVersion *r = (struct winreg_GetVersion *)_r;
			ZERO_STRUCT(r->out);
			r->out.version = talloc_zero(mem_ctx, uint32_t);
			if (r->out.version == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_GetVersion(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKCC: {
			struct winreg_OpenHKCC *r = (struct winreg_OpenHKCC *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKCC(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKDD: {
			struct winreg_OpenHKDD *r = (struct winreg_OpenHKDD *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKDD(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_QUERYMULTIPLEVALUES: {
			struct winreg_QueryMultipleValues *r = (struct winreg_QueryMultipleValues *)_r;
			ZERO_STRUCT(r->out);
			r->out.values = r->in.values;
			r->out.buffer = r->in.buffer;
			r->out.buffer_size = r->in.buffer_size;
			r->out.result = _winreg_QueryMultipleValues(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_INITIATESYSTEMSHUTDOWNEX: {
			struct winreg_InitiateSystemShutdownEx *r = (struct winreg_InitiateSystemShutdownEx *)_r;
			r->out.result = _winreg_InitiateSystemShutdownEx(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_SAVEKEYEX: {
			struct winreg_SaveKeyEx *r = (struct winreg_SaveKeyEx *)_r;
			r->out.result = _winreg_SaveKeyEx(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKPT: {
			struct winreg_OpenHKPT *r = (struct winreg_OpenHKPT *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKPT(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_OPENHKPN: {
			struct winreg_OpenHKPN *r = (struct winreg_OpenHKPN *)_r;
			ZERO_STRUCT(r->out);
			r->out.handle = talloc_zero(mem_ctx, struct policy_handle);
			if (r->out.handle == NULL) {
			return NT_STATUS_NO_MEMORY;
			}

			r->out.result = _winreg_OpenHKPN(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		case NDR_WINREG_QUERYMULTIPLEVALUES2: {
			struct winreg_QueryMultipleValues2 *r = (struct winreg_QueryMultipleValues2 *)_r;
			r->out.result = _winreg_QueryMultipleValues2(cli->pipes_struct, r);
			return NT_STATUS_OK;
		}

		default:
			return NT_STATUS_NOT_IMPLEMENTED;
	}
}

NTSTATUS rpc_winreg_init(void)
{
	return rpc_srv_register(SMB_RPC_INTERFACE_VERSION, "winreg", "winreg", &ndr_table_winreg, api_winreg_cmds, sizeof(api_winreg_cmds) / sizeof(struct api_struct));
}
